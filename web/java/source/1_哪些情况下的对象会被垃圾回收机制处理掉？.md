
## 哪些情况下的对象会被垃圾回收机制处理掉？

### 答案
	
1.所有实例都没有活动线程访问。

2.没有被其他任何实例访问的循环引用实例。

3.Java 中有不同的引用类型。判断实例是否符合垃圾收集的条件都依赖于它的引用类型。


[对象的垃圾回收和四种引用](https://blog.csdn.net/erica_1230/article/details/43883105)

[对象在内存中分为三种状态:]()

可达状态

一个对象创建以后,有一个或者多个引用变量引用该对象,那么这个对象属于可达状态

 

可恢复状态

如果程序中某个对象不再有任何引用变量引用它，他将进入可恢复状态，此时从有向图的起始顶点不能导航到该对象。在这种状态下，系统的垃圾回收机制转变回收该对象所占用的内存。在回收该对象之前，系统会调用可恢复状态的对象的finalize方法进行资源清理，如果系统调用finalize方法重新让一个以上的引用变量引用该对象，则该对象会再次变成可达状态；否则，该对象将进入不可达状态。

 
不可达状态

当对象的所有关联都被切断，且系统调用所有对象的finalize方法依然没有使该对象变成可达状态后，这个对象将永久性地失去引用，最后变成不可达状态。只有当一个对象出于不可达状态，系统才会真正回收该对象所占用的资源。


![对象状态转化图](https://raw.githubusercontent.com/supets-open/InterView/master/web/image/%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.jpg)

finalize方法

垃圾回收对象内存之前会先调用finalize方法,这个是object中的方法,注意有可能失去引用的某个对象只是占了少量内存,而且系统也没有严重内存需求,因此垃圾回收机制没有试图回收该对象占用资源,所以finalize方法也不会执行。

protected void finalize() throws Throwable

有如下几个特点:

1 不要主动调用某个对象的finalize方法,应该由垃圾回收机制调用。

2  finalize何时被调用不确定,不要认为一定可以执行。

3  执行finalize方法时,可以让该对象转又化为可达状态。

4  当执行finalize方法时,出线异常,不会报告异常,继续执行。

 

public class FinalizeTest {
 @Override
 protected void finalize() throws Throwable {
 
  super.finalize();
     System.out.println("finalize");
  ft=this;
  
 }

    public void print(){
     System.out.println("print");
    }

 static FinalizeTest  ft=null;
 
 
 
 /**
  * @param args
  * @throws InterruptedException
  */
 public static void main(String[] args) throws InterruptedException {
    new FinalizeTest();
     System.gc();

   //Thread.sleep(2000);   1

  //System.runFinalization();  2
          ft.print();
 }

}

 

这样会有空指针异常

1   去掉1的注释,注释2不去掉,就不会有异常,是因为垃圾回收机制调用了finalize方法,使得ft引用指向了该对象,该线程睡2秒钟就是为了等待垃圾回收机制回收该对象,调用finalize方法,

在该方法ft引用到对象,不会有空指针异常。

2   去掉2的注释,注释1不去掉,也不会有异常,因为强制垃圾回收机制调用可恢复对象的finalize方法



[对象有四种引用]()

强引用

创建一个对象,把这个对象赋予引用变量,就是强引用,如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

 

软引用SoftReference

如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

 

弱引用WeakReference

如果一个对象只具有弱引用，那就类似于可有可无的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

 

需引用PhantomReference

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解

被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。