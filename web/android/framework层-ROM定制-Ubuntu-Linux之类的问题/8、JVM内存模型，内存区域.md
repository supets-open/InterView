[深入理解JVM之JVM内存区域与内存分配](https://www.cnblogs.com/wangjzh/p/5258254.html)

[Java8内存模型](https://blog.csdn.net/universe_ant/article/details/58585854)

[JVM内存区域与内存模型](https://www.jianshu.com/p/51e4051de38c)


[深入理解jvm-(第十二章)Java内存模型和线程](http://blog.sina.com.cn/s/blog_17c534c120102xxal.html)



 <p>JMM(Java内存模型)源于物理机器CPU架构的内存模型，最初用于解决MP(多处理器架构)系统中的缓存一致性问题，而JVM为了屏蔽各个硬件平台和操作系统对内存访问机制的差异化，提出了JMM的概念。</p><blockquote>Java内存模型的主要目标是<b>定义程序中各个变量的访问规则</b>，即<b>在JVM中将变量存储到内存和从内存中取出变量这样的底层细节</b> 。此处的变量与Java编程里面的变量有所不同，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题（如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。 <br>JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</blockquote><p>对于JMM与JVM本身的内存模型，参照《深入理解Java虚拟机》周志明的解释，这两者本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义来看，<b>主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</b>。从更低层次上说，<b>主内存就是物理内存，而为了获取更好的执行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为运行时主要访问——读写的是工作内存</b>。</p>